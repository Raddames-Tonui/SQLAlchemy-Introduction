
#  FOLDER STRUCTURE
# my_flask_app/
# │
# ├── app.py              # Main application file
# ├── models.py           # Database models
# ├── config.py           # Configuration settings (optional)
# ├── requirements.txt    # Python dependencies
# ├── migrations/         # Database migrations folder (auto-generated by Flask-Migrate)
# │
# └── __init__.py         # Initialize the application (optional)


from flask import Flask, jsonify, request
from flask_migrate import Migrate

# Initialize the Flask application
app = Flask(__name__)

# Configure the SQLAlchemy part of the app instance
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///school.db"


from models import db, Students, Course  # Import the models and database object
migrate = Migrate(app, db)   # Bind the Migrate object to the app and db
db.init_app(app)             # Initialize the app with the db instance

@app.route('/')
def hello_world():
    return 'Hello, World!'

@app.route('/v1/students/<string:username>')
def user(username):
    return f"Hello {username}"

# Sample student list
students = ["John", "Raddames", "June", "Andrew", "Brian"]

@app.route('/students', methods=['GET'])
def fetch_students():
    if len(students) == 0:
        return jsonify({"Message" : "No students found"}), 400 
    return jsonify(students), 200     # 200 OK

@app.route('/students/<int:id>', methods=['GET']) # /students/<int:id> used to pass dynamic numbers 
def fetch_student(id):
    if id < 0 or id >= len(students):
        return jsonify({"message": "No such student"}), 404
    return jsonify(students[id]), 200



# We run a development server through treating our application module as a script with the app.run() method:
if __name__ == "__main__":
    app.run(debug=True) # for debugging purposes, it will auto reload the code 
